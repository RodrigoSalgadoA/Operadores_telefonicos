# -*- coding: utf-8 -*-
"""Sprint14.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fl2u742H5WkYkugQgGlotoSGcGY61z9C

# Hola &#x1F600;,

Soy **Hesus Garcia** ‚Äì **"Soy el √∫nico Hesus que conoces (y probablemente conocer√°s) üåü"** ‚Äì S√≠, como "Jes√∫s", pero con una H que me hace √∫nico. Puede sonar raro, pero cr√©eme, ¬°no lo olvidar√°s! Como tu revisor en Triple-Ten, estoy aqu√≠ para guiarte y ayudarte a mejorar tu c√≥digo. Si algo necesita un ajuste, no hay de qu√© preocuparse; ¬°aqu√≠ estoy para hacer que tu trabajo brille con todo su potencial! ‚ú®

Cada vez que encuentre un detalle importante en tu c√≥digo, te lo se√±alar√© para que puedas corregirlo y as√≠ te prepares para un ambiente de trabajo real, donde el l√≠der de tu equipo actuar√≠a de manera similar. Si en alg√∫n momento no logras solucionar el problema, te dar√© m√°s detalles para ayudarte en nuestra pr√≥xima oportunidad de revisi√≥n.

Es importante que cuando encuentres un comentario, **no los muevas, no los modifiques, ni los borres**.

---

### Formato de Comentarios

Revisar√© cuidadosamente cada implementaci√≥n en tu notebook para asegurar que cumpla con los requisitos y te dar√© comentarios de acuerdo al siguiente formato:


<div class="alert alert-block alert-success">
<b>Comentario del revisor</b> <a class="tocSkip"></a><br>
    
<b>√âxito</b> - ¬°Excelente trabajo! Esta parte est√° bien implementada y contribuye significativamente al an√°lisis de datos o al proyecto. Contin√∫a aplicando estas buenas pr√°cticas en futuras secciones.
    
</div>

<div class="alert alert-block alert-warning">
<b>Comentario del revisor</b> <a class="tocSkip"></a><br>
    
<b>Atenci√≥n</b> ‚ö†Ô∏è - Este c√≥digo est√° correcto, pero se puede optimizar. Considera implementar mejoras para que sea m√°s eficiente y f√°cil de leer. Esto fortalecer√° la calidad de tu proyecto.
    
</div>

<div class="alert alert-block alert-danger">
<b>Comentario del revisor</b> <a class="tocSkip"></a><br>
    
<b>A resolver</b> ‚ùó - Aqu√≠ hay un problema o error en el c√≥digo que es necesario corregir para aprobar esta secci√≥n. Por favor, revisa y corrige este punto, ya que es fundamental para la validez del an√°lisis y la precisi√≥n de los resultados.
    
</div>

---

Al final de cada revisi√≥n, recibir√°s un **Comentario General del Revisor** que incluir√°:

- **Aspectos positivos:** Un resumen de los puntos fuertes de tu proyecto.
- **√Åreas de mejora:** Sugerencias sobre aspectos donde puedes mejorar.
- **Temas adicionales para investigar:** Ideas de temas opcionales que puedes explorar por tu cuenta para desarrollar a√∫n m√°s tus habilidades.

Estos temas adicionales no son obligatorios en esta etapa, pero pueden serte √∫tiles para profundizar en el futuro.

---

Esta estructura en vi√±etas facilita la lectura y comprensi√≥n de cada parte del comentario final.

Tambi√©n puedes responderme de la siguiente manera si tienes alguna duda o quieres aclarar algo espec√≠fico:


<div class="alert alert-block alert-info">
<b>Respuesta del estudiante</b> <a class="tocSkip"></a>
    
Aqu√≠ puedes escribir tu respuesta o pregunta sobre el comentario.
    
</div>


**¬°Empecemos!** &#x1F680;

# üìò Proyecto Final: Identificaci√≥n de operadores ineficaces ‚Äì CallMeMaybe

El servicio de telefon√≠a virtual CallMeMaybe est√° desarrollando una nueva funci√≥n que brindar√° a los supervisores y las supervisores informaci√≥n sobre los operadores menos eficaces. Se considera que un operador es ineficaz si tiene una gran cantidad de llamadas entrantes perdidas (internas y externas) y un tiempo de espera prolongado para las llamadas entrantes. Adem√°s, si se supone que un operador debe realizar llamadas salientes, un n√∫mero reducido de ellas tambi√©n ser√° un signo de ineficacia.

- Lleva a cabo el an√°lisis exploratorio de datos
- Identificar operadores ineficaces
- Prueba las hip√≥tesis estad√≠sticas

## üõ†Ô∏è 1. Carga de datos y limpiea de datos
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.stats import ttest_ind, mannwhitneyu
from statsmodels.stats.proportion import proportions_ztest

# Cargar archivos subidos al entorno del notebook
calls = pd.read_csv('telecom_dataset_us.csv', parse_dates=['date'])
clients = pd.read_csv('telecom_clients_us.csv', parse_dates=['date_start'])

# Verificar nulos y tipos
print("Valores nulos en llamadas:")
print(calls.isnull().sum())
print("\nTipos de datos:")
print(calls.dtypes)

# Unir datasets por user_id
df = calls.merge(clients, on='user_id', how='left')
df.head()

"""üîç columna internal (117 valores nulos)

* Esta columna indica si la llamada fue interna (entre operadores del mismo cliente).

* Los nulos podr√≠an corresponder a llamadas externas, pero no est√° expl√≠cito.

‚úÖTratamiento para los datos:

* Cambiar estos valores nulos como llamadas externas y hacer un gr√°fico circular a partir de esto.
"""

df[df['operator_id'].isnull()].describe()

"""¬øQu√© nos dicen estos datos?
* 8172 registros sin operator_id.

* La mayor√≠a tienen calls_count > 1, y algunos llegan hasta 2168 llamadas.

* El tiempo de espera (wait_time) tiene una media de 167 segundos, con valores m√°ximos superiores a 42,000 segundos.

üîç Esto indica que no son registros vac√≠os ni errores triviales. Son llamadas reales, pero no de un operador espec√≠fico.

üß† ¬øQu√© podr√≠a significar la ausencia de operator_id?
* Llamadas autom√°ticas (llamadas programadas, buz√≥n, cola de espera).

* Llamadas abandonadas antes de ser atendidas.

* Errores de registro o llamadas no asignadas por el sistema.

‚úÖ Tratamiento d elos datos

Excluir del an√°lisis por operador
* Como el objetivo es evaluar el desempe√±o individual de operadores, estos registros no aportan.

* Podemos eliminarlos solo para esa parte del an√°lisis:
"""

df = df.dropna(subset=['operator_id'])

"""## üìä 2. An√°lisis exploratorio de datos"""

#Histograma de duraci√≥n de llamadas
plt.figure(figsize=(10, 5))
sns.histplot(df[df['call_duration'] < 1000]['call_duration'], bins=60, kde=True)
plt.title('Duraci√≥n de llamadas (filtradas < 1000 seg)')
plt.xlabel('Segundos')
plt.ylabel('Cantidad de llamadas')
plt.xlim(0, 1000)
plt.grid(True)
plt.tight_layout()
plt.show()

plt.figure(figsize=(10, 5))
sns.histplot(df[df['total_call_duration'] < 1500]['total_call_duration'], bins=60, kde=True)
plt.title('Duraci√≥n total de llamadas con tiempo de espera (filtradas < 1500 seg)')
plt.xlabel('Segundos')
plt.ylabel('Cantidad de llamadas')
plt.xlim(0, 1500)
plt.grid(True)
plt.tight_layout()
plt.show()

#Histograma de llamadas por d√≠a
# Agrupar llamadas por d√≠a
calls_per_day = df.groupby('date')['calls_count'].sum()

# Crear gr√°fico
plt.figure(figsize=(14, 6))
ax = calls_per_day.plot(kind='bar', color='steelblue')

# Ajustar etiquetas del eje X: mostrar solo cada 5 fechas
xticks = ax.get_xticks()
ax.set_xticks(xticks[::5])  # Mostrar cada 5 etiquetas
ax.set_xticklabels(calls_per_day.index.strftime('%Y-%m-%d')[::5], rotation=45)

# T√≠tulos y etiquetas
plt.title('N√∫mero de llamadas por d√≠a')
plt.xlabel('Fecha')
plt.ylabel('Cantidad de llamadas')
plt.grid(axis='y', linestyle='--', alpha=0.5)
plt.tight_layout()
plt.show()

# Gr√°fico circular con valores corregidos
df['internal'].value_counts().plot.pie(autopct='%1.1f%%', labels=['Externa', 'Interna'], startangle=90)
plt.title('Participaci√≥n de llamadas internas vs externas')
plt.ylabel('')
plt.show

"""<div class="alert alert-block alert-success">

<b>Comentario del revisor</b> <a class="tocSkip"></a><br>

<b>√âxito</b> - Excelente secci√≥n de an√°lisis exploratorio. Has utilizado histogramas, gr√°ficos de barras y gr√°ficos circulares que permiten visualizar el comportamiento de las variables clave de manera clara y efectiva. El filtrado de outliers en la duraci√≥n de llamadas tambi√©n fue adecuado. Este tipo de EDA bien fundamentado permite tomar mejores decisiones en fases posteriores del proyecto. ¬°Muy bien hecho!

</div>

## üö® 3. Identificaci√≥n de operadores ineficientes
"""

#Alta cifra de llamadas entrantes perdidas
in_calls = df[df['direction'] == 'in']
missed_by_operator = in_calls.groupby('operator_id').agg({
    'is_missed_call': 'sum',
    'calls_count': 'sum'
})
missed_by_operator['missed_rate'] = missed_by_operator['is_missed_call'] / missed_by_operator['calls_count']

#Tiempos de espera largos
df['wait_time'] = df['total_call_duration'] - df['call_duration']
wait_by_operator = df.groupby('operator_id')['wait_time'].mean()

#Bajo n√∫mero de llamadas de salida
out_calls = df[df['direction'] == 'out']
out_by_operator = out_calls.groupby('operator_id')['calls_count'].sum()
low_out_threshold = out_by_operator.quantile(0.25)

#Dividir por plan de tarifa
operator_tariff = df.groupby(['operator_id', 'tariff_plan']).size().reset_index(name='activity')
operator_tariff

#Destacar a operadores ineficientes
inefficient = pd.DataFrame({
    'missed_rate': missed_by_operator['missed_rate'],
    'avg_wait': wait_by_operator,
    'out_calls': out_by_operator
}).dropna()

inefficient['inefficient'] = (
    (inefficient['missed_rate'] > inefficient['missed_rate'].quantile(0.75)) &
    (inefficient['avg_wait'] > inefficient['avg_wait'].quantile(0.75)) &
    (inefficient['out_calls'] < low_out_threshold)
)

"""## üìê 4. Pruebas estad√≠sticas

Al tratar de realizar una prueba T los datos nos dieron una "catastrophic cancellation".

* Esto ocurre cuando los valores en ambas muestras (ineff['avg_wait'] y eff['avg_wait']) son casi id√©nticos.

* El c√°lculo de la varianza se vuelve inestable, lo que hace que la precis√≥n del resultado no sea buena.

Divide entre cero

* Puede suceder si una de las muestras tiene muy pocos elementos o todos los valores son iguales.

* Esto provoca que la desviaci√≥n est√°ndar sea cero, y al dividir por ella, se genera un error num√©rico.

‚úÖ Soluci√≥n: Usar una prueba no param√©trica m√°s robusta
La prueba de Mann‚ÄìWhitney U no requiere suposiciones sobre la distribuci√≥n:
"""

#Comparaci√≥n de duraci√≥n promedio
eff = inefficient[inefficient['inefficient'] == False]

ineff = inefficient[inefficient['inefficient'] == True]

u_stat, p_u = mannwhitneyu(ineff['avg_wait'], eff['avg_wait'], alternative='two-sided')
print(f"Mann‚ÄìWhitney U: U={u_stat:.2f}, p={p_u:.4f}")

"""## üìå Interpretaci√≥n del resultado

* El valor p = 0.1556 es mayor que 0.05, lo que sugiere que no hay evidencia suficiente para afirmar que los tiempos de espera son diferentes entre operadores eficientes e ineficientes.

* Podemos interpretarlo: aunque los operadores ineficientes podr√≠an parecer m√°s lentos, estad√≠sticamente no se puede confirmar esa diferencia con los datos actuales.
"""

#Prueba de proporciones
count = np.array([
    ineff['missed_rate'].mean() * ineff.shape[0],
    eff['missed_rate'].mean() * eff.shape[0]
])
nobs = np.array([ineff.shape[0], eff.shape[0]])
stat, p = proportions_ztest(count, nobs)
print(f"Prueba de proporciones: z={stat:.2f}, p={p:.4f}")

"""## üìå Interpretaci√≥n del resultado

z = -0.04: el estad√≠stico z est√° muy cerca de cero, lo que indica que la diferencia entre las proporciones de llamadas perdidas en operadores eficientes e ineficientes es pr√°cticamente nula.

p = 0.9676: este valor p es much√≠simo m√°s grande que el nivel de significancia (0.05), lo que significa que no hay evidencia estad√≠stica para afirmar que las tasas de llamadas perdidas son diferentes entre ambos grupos.

<div class="alert alert-block alert-success">

<b>Comentario del revisor</b> <a class="tocSkip"></a><br>

<b>√âxito</b> - Excelente criterio al identificar un problema de cancelaci√≥n catastr√≥fica con la prueba T y cambiar a una prueba no param√©trica m√°s adecuada (Mann‚ÄìWhitney U). Adem√°s, el uso de la prueba de proporciones Z para comparar tasas de llamadas perdidas entre grupos fue apropiado. Tus interpretaciones son correctas, prudentes y bien contextualizadas con relaci√≥n al objetivo del proyecto. Este enfoque cuidadoso refleja pensamiento cr√≠tico estad√≠stico. ¬°Muy bien!

</div>

## üîç Conclusiones Generales

La proporci√≥n de llamadas perdidas entre operadores ineficientes y eficientes no es significativamente distinta.

Esto contradice la hip√≥tesis de que los operadores ineficaces pierden m√°s llamadas. Puede deberse a varias razones:

* El criterio de ineficiencia que estamos usando (combinaci√≥n de espera, llamadas salientes, etc.) no est√° correlacionado con la tasa de abandono.

* La muestra de operadores ineficientes es muy peque√±a, lo que no da un resultado contundente.

* El sistema distribuye las llamadas de forma que todos los operadores enfrentan tasas similares de abandono, independientemente de su desempe√±o.

## üß† ¬øQu√© hacer ahora?
* Replantear el criterio de ineficiencia: ¬øquiz√°s poner m√°s el tiempo de espera o el volumen de llamadas?

* Analizar por segmentos: ¬øhay diferencias por tipo de cliente (tariff_plan) o por d√≠a de la semana?

* Visualizar la distribuci√≥n de missed_rate con boxplots para ver si hay outliers o patrones ocultos.

## üìö Referencias
1. Virtanen, P., Gommers, R., Oliphant, T. E., Haberland, M., Reddy, T., Cournapeau, D., ... & van Mulbregt, P. (2020). SciPy 1.0: Fundamental algorithms for scientific computing in Python. Nature Methods, 17(3), 261‚Äì272. https://doi.org/10.1038/s41592-019-0686-2

2. Cohen, J. (1988). Statistical power analysis for the behavioral sciences (2nd ed.). Hillsdale, NJ: Lawrence Erlbaum Associates.

3. McKinney, W. (2010). Data structures for statistical computing in Python. In Proceedings of the 9th Python in Science Conference (pp. 51‚Äì56).

4. Waskom, M. L. (2021). seaborn: statistical data visualization. Journal of Open Source Software, 6(60), 3021. https://doi.org/10.21105/joss.03021

<div class="alert alert-block alert-success">

<b>Comentario del revisor</b> <a class="tocSkip"></a>

¬°Felicidades! Tu proyecto est√° <b>aprobado</b>. Has hecho un excelente trabajo en la identificaci√≥n de operadores ineficaces, demostrando dominio en el tratamiento de datos reales, uso correcto de estad√≠sticas no param√©tricas, y una s√≥lida interpretaci√≥n de resultados.

#### Puntos Positivos:

- **Limpieza de datos bien argumentada:** Identificaste correctamente la naturaleza de los valores nulos y aplicaste un tratamiento justificado.
- **Visualizaci√≥n clara:** Gr√°ficos bien elegidos que enriquecen el an√°lisis.
- **Detecci√≥n de ineficiencia:** Criterios l√≥gicos para segmentar operadores y buen manejo de `groupby`, `agg` y filtros.
- **Uso apropiado de pruebas estad√≠sticas:** Resolviste correctamente la cancelaci√≥n catastr√≥fica y aplicaste pruebas robustas como Mann‚ÄìWhitney y proporciones Z.
- **Interpretaci√≥n cuidadosa:** Buen an√°lisis de los resultados y consideraci√≥n de limitaciones de la muestra.

#### √Åreas para Seguir Investigando:

- **Automatizaci√≥n y reutilizaci√≥n de c√≥digo:** Podr√≠as encapsular algunas l√≥gicas de selecci√≥n de ineficiencia en funciones reutilizables.
- **An√°lisis multivariado:** Considerar modelos de regresi√≥n log√≠stica para identificar predictores m√°s robustos de ineficiencia.
- **Visualizaci√≥n final:** Incluir un resumen visual de operadores destacados (ineficientes vs eficientes) ayudar√≠a a comunicar los hallazgos m√°s claramente.

¬°Excelente enfoque anal√≠tico y t√©cnica! Contin√∫a por este camino y no dejes de explorar nuevas formas de visualizar y modelar tus hip√≥tesis. üí°üìàüîç

</div>
"""

